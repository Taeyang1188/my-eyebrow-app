<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>眉완성: 내 인생 눈썹 찾기</title>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        :root {
            --primary-color: #6a5acd; /* SlateBlue */
            --secondary-color: #f0e6ff;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --container-bg: #ffffff;
            --border-radius: 16px;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
            color: var(--text-color);
        }
        .main-container {
            width: 100%;
            max-width: 500px;
            background-color: var(--container-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 25px;
            box-sizing: border-box;
            text-align: center;
        }
        h1, h2, h3, h4 {
            margin: 0 0 15px;
            color: var(--primary-color);
        }
        h1 { font-size: 2rem; }
        h2 { font-size: 1.6rem; }
        h4 { font-size: 1.1rem; margin-top: 20px;}
        p { line-height: 1.7; margin: 0 0 20px; }
        .btn {
            display: block; width: 100%; padding: 15px; margin: 10px 0;
            border: none; border-radius: 12px; background-color: var(--primary-color);
            color: white; font-size: 1.1rem; font-weight: bold; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn:hover { background-color: #5a4ab9; }
        .btn:active { transform: scale(0.98); }
        .btn.secondary {
             background-color: #e9ecef; color: var(--text-color);
        }
        #photo-page .btn.secondary {
            display: inline-block;
            width: auto;
            padding: 15px 30px;
        }
        .btn.secondary:hover { background-color: #d3d9df; }
        .page { display: none; }
        .page.active { display: block; }
        #guide-container {
            width: 100%; aspect-ratio: 3 / 4; background-color: #e9ecef;
            border: 2px dashed #ced4da; border-radius: 12px;
            position: relative; overflow: hidden; user-select: none; margin: 20px 0;
        }
        #user-image, #overlay-canvas, #guideline-svg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%; max-height: 100%;
            height: auto; width: 80%;
        }
        #user-image { z-index: 10; cursor: grab; }
        #user-image:active { cursor: grabbing; }
        #guideline-svg { z-index: 20; pointer-events: none; }
        #overlay-canvas { z-index: 30; pointer-events: none; }
        #guideline-svg .draggable-line {
            pointer-events: all;
            cursor: ns-resize;
            stroke-width: 8px;
            stroke: rgba(0,0,0,0);
        }
        .sliders {
            margin-top: 20px; padding: 20px;
            background-color: #f8f9fa; border-radius: 8px;
        }
        .slider-group {
            display: flex; align-items: center;
            gap: 15px; margin-bottom: 15px;
        }
        .slider-group label { font-size: 14px; width: 100px; text-align: left;}
        input[type="range"] { flex-grow: 1; }
        .description-text {
            font-size: 0.8em; color: #888; text-align: left;
            padding-left: 10px; border-left: 3px solid #e0e0e0;
        }
        .question { margin-bottom: 30px; text-align: left; }
        .question p { font-weight: 500; margin-bottom: 15px; }
        .options { display: flex; flex-direction: column; gap: 10px; }
        .result-card {
            background-color: var(--secondary-color); border-radius: 12px;
            padding: 20px; margin-bottom: 15px; text-align: left;
        }
        .result-card h3 { color: var(--primary-color); border-bottom: 2px solid var(--primary-color); padding-bottom: 10px; margin-bottom: 15px;}
        .result-card ul { padding-left: 20px; margin: 0; list-style-type: none;}
        .result-card li { margin-bottom: 12px; }
        /* [추가] 사진 분석 결과 텍스트 스타일 */
        .photo-basis {
            font-size: 0.8em;
            color: #666;
            display: block;
            padding-left: 10px;
            border-left: 2px solid var(--primary-color);
            margin-top: 5px;
        }
        #loader {
            border: 8px solid #f3f3f3; border-radius: 50%;
            border-top: 8px solid var(--primary-color);
            width: 60px; height: 60px;
            animation: spin 1s linear infinite; margin: 30px auto; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="main-container">

        <div id="start-page" class="page active">
            <h1>眉완성</h1>
            <p><strong>내 얼굴에 딱 맞는 인생 눈썹을 찾아보세요!</strong><br>두 가지 방법 중 하나를 선택해 진단을 시작할 수 있습니다.</p>
            <button class="btn" onclick="showPage('photo-page')">📸 사진으로 분석하기</button>
            <button class="btn" onclick="showPage('quiz-page')">✍️ 설문으로 진단하기</button>
            <p style="font-size: 0.8em; color: #888; margin-top: 20px;">
                사진은 서버에 저장되지 않으며, 분석은 모두 사용자의 기기에서만 이루어집니다.
            </p>
        </div>

        <div id="photo-page" class="page">
            <h2>사진으로 분석하기</h2>
            <p>정면을 바라보는 선명한 사진을 올리고<br>가이드라인에 맞춰 얼굴을 조정해주세요.</p>
            
            <label for="file-input" class="btn secondary">🖼️ 사진 선택</label>
            <input type="file" id="file-input" accept="image/*" style="display:none;">

            <div id="guide-container">
                <svg id="guideline-svg" viewbox="0 0 300 400" preserveAspectRatio="xMidYMid meet">
                    <ellipse id="oval-guide" cx="150" cy="200" rx="100" ry="130" stroke="rgba(0,0,0,0.5)" stroke-width="2" stroke-dasharray="5,5" fill="none" />
                    <line id="red-line" x1="50" y1="200" x2="250" y2="200" stroke="red" stroke-width="1.5" />
                    <line id="blue-line" x1="150" y1="70" x2="150" y2="330" stroke="blue" stroke-width="1.5" />
                    <line class="green-line" x1="75" y1="70" x2="75" y2="330" stroke="green" stroke-width="1" />
                    <line class="green-line" x1="125" y1="70" x2="125" y2="330" stroke="green" stroke-width="1" />
                    <line class="green-line" x1="175" y1="70" x2="175" y2="330" stroke="green" stroke-width="1" />
                    <line class="green-line" x1="225" y1="70" x2="225" y2="330" stroke="green" stroke-width="1" />
                    <line id="draggable-line-visual" x1="50" y1="220" x2="250" y2="220" stroke="skyblue" stroke-width="2" />
                    <line class="draggable-line" id="draggable-line-handle" x1="50" y1="220" x2="250" y2="220" />
                </svg>
                <img id="user-image" src="" alt="User's face" style="display:none;">
                <canvas id="overlay-canvas"></canvas>
            </div>

            <div id="photo-controls" style="display:none;">
                <div class="sliders">
                    <p class="description-text"><strong>사진 조절</strong></p>
                    <div class="slider-group">
                        <label for="size-slider">사진 크기</label>
                        <input type="range" id="size-slider" min="10" max="250" value="80">
                    </div>
                    <div class="slider-group">
                        <label for="opacity-slider">사진 투명도</label>
                        <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="0.7">
                    </div>
                </div>
                <div class="sliders">
                     <p class="description-text"><strong>가이드라인 조절</strong></p>
                    <div class="slider-group">
                        <label for="guideline-size-slider">전체 크기</label>
                        <input type="range" id="guideline-size-slider" min="50" max="150" value="100">
                    </div>
                     <p class="description-text" style="font-size:0.75em; margin-top: 5px;">
                        가이드라인을 조절하여 얼굴 비율을 직접 확인해보세요.
                    </p>
                </div>
            </div>
            
            <p class="description-text" style="margin-top:15px; font-size: 0.9em;">
                <strong>동그란 얼굴:</strong> 얼굴의 가로와 세로 길이가 1:1.1 정도로 비슷<br>
                <strong>타원형 얼굴:</strong> 가로보다 세로 길이가 1:1.4 이상으로 훨씬 김
            </p>
            
            <div id="loader"></div>
            <button class="btn" id="analyze-btn" onclick="analyzePhoto()" style="display:none;">결과 분석하기</button>
            <button class="btn secondary" onclick="showPage('start-page')">뒤로 가기</button>
        </div>

        <div id="quiz-page" class="page">
            <h2>설문으로 진단하기</h2>
            <p>아래 질문에 답하여<br>자신에게 꼭 맞는 눈썹 스타일을 찾아보세요.</p>
            <form id="quiz-form">
                <div class="question">
                    <p>1. 내 얼굴의 특징은 어디에 가깝나요?</p>
                    <div class="options">
                        <label><input type="radio" name="q1" value="A"> 얼굴이 길거나, 눈과 눈썹 사이가 멀다.</label>
                        <label><input type="radio" name="q1" value="B"> 얼굴이 짧거나, 눈과 눈썹 사이가 좁다.</label>
                    </div>
                </div>
                <div class="question">
                    <p>2. 나의 전체적인 인상이나 얼굴 라인은?</p>
                    <div class="options">
                        <label><input type="radio" name="q2" value="C"> 얼굴선이 둥글고, 청순하고 부드러운 인상이다.</label>
                        <label><input type="radio" name="q2" value="D"> 얼굴선이 각지고, 세련되고 또렷한 인상이다.</label>
                    </div>
                </div>
                <div class="question">
                    <p>3. 내 눈 모양은 어떤가요?</p>
                    <div class="options">
                        <label><input type="radio" name="q3" value="E"> 눈이 전체적으로 동그란 편이다.</label>
                        <label><input type="radio" name="q3" value="F"> 눈이 가로로 긴 편이다.</label>
                    </div>
                </div>
                <div class="question">
                    <p>4. 내 이목구비는 얼굴 중앙에 모여있는 편인가요?</p>
                    <div class="options">
                        <label><input type="radio" name="q4" value="A"> 이목구비가 중앙에 모여있고, 눈 사이가 가깝다 (내심안).</label>
                        <label><input type="radio" name="q4" value="B"> 이목구비가 넓게 퍼져있고, 눈 사이가 멀다 (외심안).</label>
                    </div>
                </div>
                <div class="question">
                    <p>5. 내 얼굴의 가로/세로 비율은 어떤가요?</p>
                    <div class="options">
                        <label><input type="radio" name="q5" value="C"> 가로 대비 세로 길이가 짧은 동그란 얼굴형이다.</label>
                        <label><input type="radio" name="q5" value="D"> 가로 대비 세로 길이가 긴 타원형/긴 얼굴형이다.</label>
                    </div>
                </div>
                <div class="question">
                    <p>6. 나의 미간 너비와 추구하는 인상은?</p>
                    <div class="options">
                        <label><input type="radio" name="q6" value="E"> 미간이 좁은 편이며, 부드러운 인상을 원한다.</label>
                        <label><input type="radio" name="q6" value="F"> 미간이 넓은 편이며, 또렷한 인상을 원한다.</label>
                    </div>
                </div>
                <button type="button" class="btn" onclick="analyzeQuiz()">결과 확인하기</button>
                <button type="button" class="btn secondary" onclick="showPage('start-page')">뒤로 가기</button>
            </form>
        </div>

        <div id="result-page" class="page">
            <h2>진단 결과 🧐</h2>
            <p>당신에게 어울리는 최고의 눈썹 스타일을 추천합니다!</p>
            <div id="result-content"></div>
            <button class="btn" onclick="showPage('start-page')">다시 하기</button>
        </div>
        
    </div>

<script>
    const pages = document.querySelectorAll('.page');
    const loader = document.getElementById('loader');
    let modelsLoaded = false;

    function showPage(pageId) {
        pages.forEach(page => page.classList.remove('active'));
        const targetPage = document.getElementById(pageId);
        if (targetPage) {
            targetPage.classList.add('active');
        }
        if (pageId === 'start-page') {
            const fileInput = document.getElementById('file-input');
            const userImage = document.getElementById('user-image');
            const photoControls = document.getElementById('photo-controls');
            const analyzeBtn = document.getElementById('analyze-btn');
            const canvas = document.getElementById('overlay-canvas');
            if(fileInput) fileInput.value = '';
            if(userImage) { userImage.src = ''; userImage.style.display = 'none'; }
            if(photoControls) photoControls.style.display = 'none';
            if(analyzeBtn) analyzeBtn.style.display = 'none';
            if(canvas) { canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height); }
        }
    }

    async function loadModels() {
        const MODEL_URL = './models';
        try {
            await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
            await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
            modelsLoaded = true;
            console.log("모델 로딩 완료!");
        } catch (error) {
            console.error("모델 로딩 실패:", error);
            alert("분석 모델을 불러오는 데 실패했습니다.");
        }
    }
    loadModels();

    const fileInput = document.getElementById('file-input');
    const userImage = document.getElementById('user-image');
    const photoControls = document.getElementById('photo-controls');
    const analyzeBtn = document.getElementById('analyze-btn');
    const guideContainer = document.getElementById('guide-container');

    if (fileInput) {
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            document.getElementById('overlay-canvas').getContext('2d').clearRect(0,0,300,400);
            const reader = new FileReader();
            reader.onload = (e) => {
                userImage.src = e.target.result;
                userImage.style.display = 'block';
                if(photoControls) photoControls.style.display = 'block';
                if(analyzeBtn) analyzeBtn.style.display = 'block';
                document.getElementById('size-slider').value = 80;
                userImage.style.width = '80%';
                document.getElementById('opacity-slider').value = 0.7;
                userImage.style.opacity = '0.7';
                document.getElementById('guideline-size-slider').value = 100;
                updateGuidelineSize(100);
            };
            reader.readAsDataURL(file);
        });
    }

    const sizeSlider = document.getElementById('size-slider');
    const opacitySlider = document.getElementById('opacity-slider');
    if (sizeSlider) {
        sizeSlider.addEventListener('input', (e) => { if(userImage) userImage.style.width = `${e.target.value}%`; });
    }
    if (opacitySlider) {
        opacitySlider.addEventListener('input', (e) => { if(userImage) userImage.style.opacity = e.target.value; });
    }
    
    const guidelineSVG = document.getElementById('guideline-svg');
    const ovalGuide = document.getElementById('oval-guide');
    const redLine = document.getElementById('red-line');
    const blueLine = document.getElementById('blue-line');
    const greenLines = guidelineSVG.querySelectorAll('.green-line');
    const draggableLineVisual = document.getElementById('draggable-line-visual');
    const draggableLineHandle = document.getElementById('draggable-line-handle');
    const guidelineSizeSlider = document.getElementById('guideline-size-slider');
    const IDEAL_ASPECT_RATIO = 1.3;
    
    function updateGuidelineSize(sizePercent) {
        const svgWidth = 300;
        const baseRx = svgWidth / 3; 
        const rx = baseRx * (sizePercent / 100);
        const ry = rx * IDEAL_ASPECT_RATIO;
        ovalGuide.setAttribute('rx', rx);
        ovalGuide.setAttribute('ry', ry);
        redLine.setAttribute('x1', 150 - rx);
        redLine.setAttribute('x2', 150 + rx);
        blueLine.setAttribute('y1', 200 - ry);
        blueLine.setAttribute('y2', 200 + ry);
        const sectionWidth = (rx * 2) / 4;
        const startX = 150 - rx;
        greenLines.forEach((line, index) => {
            const xPos = startX + (sectionWidth * (index + 1));
            line.setAttribute('x1', xPos);
            line.setAttribute('x2', xPos);
            line.setAttribute('y1', 200 - ry);
            line.setAttribute('y2', 200 + ry);
        });
        draggableLineVisual.setAttribute('x1', 150 - rx);
        draggableLineVisual.setAttribute('x2', 150 + rx);
        draggableLineHandle.setAttribute('x1', 150 - rx);
        draggableLineHandle.setAttribute('x2', 150 + rx);
    }
    if(guidelineSizeSlider) {
        guidelineSizeSlider.addEventListener('input', (e) => {
            updateGuidelineSize(e.target.value);
        });
    }
    updateGuidelineSize(100);
    
    let isImageDragging = false;
    let isLineDragging = false;
    let startX, startY, initialLeft, initialTop;
    if (guideContainer) {
        guideContainer.addEventListener('mousedown', e => {
            if (e.target.id === 'draggable-line-handle') {
                isLineDragging = true;
                if(guidelineSVG) guidelineSVG.style.pointerEvents = 'all';
                return;
            }
            if (!userImage.src || userImage.style.display === 'none') return;
            e.preventDefault();
            isImageDragging = true;
            userImage.style.cursor = 'grabbing';
            startX = e.clientX;
            startY = e.clientY;
            initialLeft = userImage.offsetLeft;
            initialTop = userImage.offsetTop;
        });
    }
    window.addEventListener('mousemove', (e) => {
        if (isLineDragging && guidelineSVG) {
            const CTM = guidelineSVG.getScreenCTM().inverse();
            const pt = guidelineSVG.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM);
            draggableLineVisual.setAttribute('y1', svgP.y);
            draggableLineVisual.setAttribute('y2', svgP.y);
            draggableLineHandle.setAttribute('y1', svgP.y);
            draggableLineHandle.setAttribute('y2', svgP.y);
            return;
        }
        if (isImageDragging && userImage) {
            userImage.style.left = `${initialLeft + (e.clientX - startX)}px`;
            userImage.style.top = `${initialTop + (e.clientY - startY)}px`;
        }
    });
    window.addEventListener('mouseup', () => {
        if(isLineDragging) {
            isLineDragging = false;
            if(guidelineSVG) guidelineSVG.style.pointerEvents = 'none';
        }
        if(isImageDragging) {
            isImageDragging = false;
            if(userImage) userImage.style.cursor = 'grab';
        }
    });

    async function analyzePhoto() {
        if (!modelsLoaded) { alert("분석 모델이 아직 로딩 중입니다."); return; }
        if (!userImage.src || userImage.style.display === 'none') { alert("먼저 사진을 선택해주세요."); return; }
        if(loader) loader.style.display = 'block';
        if(analyzeBtn) analyzeBtn.style.display = 'none';
        try {
            const detection = await faceapi.detectSingleFace(userImage, new faceapi.SsdMobilenetv1Options()).withFaceLandmarks();
            if (!detection) {
                if(loader) loader.style.display = 'none';
                if(analyzeBtn) analyzeBtn.style.display = 'block';
                alert("얼굴을 인식할 수 없습니다. 더 선명하고 정면을 바라보는 사진을 사용해주세요.");
                return;
            }
            const canvas = document.getElementById('overlay-canvas');
            const ctx = canvas.getContext('2d');
            const imageRect = userImage.getBoundingClientRect();
            const containerRect = guideContainer.getBoundingClientRect();
            canvas.style.top = `${imageRect.top - containerRect.top}px`;
            canvas.style.left = `${imageRect.left - containerRect.left}px`;
            canvas.style.width = `${imageRect.width}px`;
            canvas.style.height = `${imageRect.height}px`;
            canvas.width = imageRect.width;
            canvas.height = imageRect.height;
            const displaySize = { width: imageRect.width, height: imageRect.height };
            const resizedDetections = faceapi.resizeResults(detection, displaySize);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);
            const landmarks = detection.landmarks;
            const jaw = landmarks.getJawOutline();
            const leftEye = landmarks.getLeftEye();
            const rightEye = landmarks.getRightEye();

            let score = 0;
            const faceHeight = jaw[8].y - (jaw[0].y + jaw[16].y) / 2;
            const faceWidth = jaw[16].x - jaw[0].x;
            const aspectRatio = faceHeight / faceWidth;
            if (aspectRatio > 1.3) score++;
            const leftEyeCenterY = (leftEye[1].y + leftEye[2].y + leftEye[4].y + leftEye[5].y) / 4;
            const leftEyebrowY = (landmarks.getLeftEyeBrow()[0].y + landmarks.getLeftEyeBrow()[1].y + landmarks.getLeftEyeBrow()[2].y + landmarks.getLeftEyeBrow()[3].y + landmarks.getLeftEyeBrow()[4].y) / 5;
            const eyeToEyebrowDistance = leftEyeCenterY - leftEyebrowY;
            const leftEyeHeight = (leftEye[4].y + leftEye[5].y) / 2 - (leftEye[1].y + leftEye[2].y) / 2;
            const normalizedDistance = eyeToEyebrowDistance / leftEyeHeight;
            if (normalizedDistance > 1.0) score++;
            const step1 = (score >= 1) ? 'A' : 'B';
            
            const p1 = jaw[2], p2 = jaw[4], p3 = jaw[8];
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.sqrt(v1.x**2 + v1.y**2), magnitude2 = Math.sqrt(v2.x**2 + v2.y**2);
            const jawAngle = Math.acos(dotProduct / (magnitude1 * magnitude2)) * (180 / Math.PI);
            const step2 = (jawAngle < 145) ? 'D' : 'C';
            
            const leftEyeWidth = leftEye[3].x - leftEye[0].x;
            const step3 = (leftEyeWidth / leftEyeHeight < 3.0) ? 'E' : 'F';
            
            const midEyesX = (leftEye[0].x + rightEye[3].x) / 2;
            const eyeSpreadRatio = Math.abs(midEyesX - landmarks.getNose()[0].x) / faceWidth;
            const step4 = (eyeSpreadRatio < 0.03) ? 'A' : 'B';
            
            const step5 = (aspectRatio < 1.2) ? 'C' : 'D';
            
            const step6 = (step4 === 'A' || step2 === 'C') ? 'E' : 'F';
            
            const analysisResult = { step1, step2, step3, step4, step5, step6 };
            displayResults(analysisResult, true); // 사진 분석임을 알림
            showPage('result-page');
        } catch (error) {
            console.error("사진 분석 중 오류 발생:", error);
            alert("사진을 분석하는 중에 오류가 발생했습니다. 다른 사진으로 시도해보거나, 설문으로 진단하는 방법을 이용해주세요.");
        } finally {
            if(loader) loader.style.display = 'none';
            if(analyzeBtn) analyzeBtn.style.display = 'block';
        }
    }

    function analyzeQuiz() {
        const form = document.getElementById('quiz-form');
        const analysisResult = {
            step1: form.elements['q1'].value,
            step2: form.elements['q2'].value,
            step3: form.elements['q3'].value,
            step4: form.elements['q4'].value,
            step5: form.elements['q5'].value,
            step6: form.elements['q6'].value,
        };
        if (Object.values(analysisResult).some(v => !v)) {
            alert("모든 질문에 답변해주세요!");
            return;
        }
        displayResults(analysisResult, false); // 설문 분석임을 알림
        showPage('result-page');
    }

    function displayResults(analysis, fromPhoto = false) {
        const content = document.getElementById('result-content');
        if (!content) return;

        // 추천 멘트 텍스트
        const resultTexts = {
            step1: { A: "도톰한", B: "얇은" },
            step2: { C: "산이 없는 부드러운 곡선 형태", D: "산이 있는 직선적이고 각진 형태" },
            step3: { E: "아래쪽을 아치처럼 파주는 곡선형", F: "아래쪽이 완만한 일자형" },
            step4: { A: "산이 길고 꼬리가 짧은 형태", B: "산이 짧고 꼬리가 긴 형태" },
            step5: { C: "얼굴이 덜 동그래 보이도록 조금 길게", D: "얼굴의 세로 길이를 보완하도록 조금 짧게" },
            step6: { E: "옅고 부드럽게 표현하는", F: "또렷하고 결을 살려 표현하는" }
        };

        // [추가] 사진 분석 시 보여줄 근거 텍스트
        const photoBasisTexts = {
            step1: { A: "얼굴이 길거나 눈과 눈썹 사이가 먼 편", B: "얼굴이 짧거나 눈과 눈썹 사이가 좁은 편" },
            step2: { C: "턱선이 145도 이상으로 부드러운 편", D: "턱선이 145도 미만으로 각진 편" },
            step3: { E: "눈의 세로 비율이 높아 동그란 편", F: "눈의 가로 비율이 높아 긴 편" },
            step4: { A: "이목구비가 중앙에 모여있는 편", B: "이목구비가 바깥으로 퍼져있는 편" },
            step5: { C: "얼굴 세로/가로 비율이 1.2 미만으로 동그란 편", D: "얼굴 세로/가로 비율이 1.2 이상으로 긴 편" },
            step6: { E: "부드러운 인상(내심안 또는 둥근 턱)", F: "또렷한 인상(외심안 또는 각진 턱)" }
        };

        let title, intro, outro;
        if (analysis.step2 === 'C') {
            title = `당신의 매력을 극대화할 "<strong>부드럽고 청순한 동안 눈썹</strong>"`;
            intro = "축하드립니다! 당신은 부드럽고 청순하며 어려 보이는 동안 인상을 가장 잘 어필할 수 있는 타입입니다. 당신의 매력을 더욱 돋보이게 할 눈썹은 과도한 각 없이 부드러운 곡선 형태를 유지하며, 전체적으로 완만하고 자연스러운 흐름을 가지는 것이 핵심입니다.";
            outro = "이 모든 요소를 종합하여 당신의 얼굴에 찰떡같이 어울리는 눈썹을 완성해 보세요. 자연스러운 아름다움으로 당신의 청순하고 귀여운 매력을 한껏 뽐낼 수 있을 것입니다!";
        } else {
            title = `당신의 품격을 높일 "<strong>세련되고 뚜렷한 성숙 눈썹</strong>"`;
            intro = "축하드립니다! 당신은 세련되고 뚜렷하며 고급스러운 성숙한 인상을 가장 잘 나타낼 수 있는 타입입니다. 당신의 매력을 더욱 강조할 눈썹은 직선적인 요소를 활용하여 또렷한 인상을 부여하고, 적절한 산을 통해 입체감과 시원함을 더하는 것이 중요합니다.";
            outro = "이 모든 요소를 종합하여 당신의 얼굴에 찰떡같이 어울리는 눈썹을 완성해 보세요. 당신의 세련되고 강렬한 매력을 더욱 빛나게 할 것입니다!";
        }
        
        let listItemsHTML = '';
        for (let i = 1; i <= 6; i++) {
            const stepKey = `step${i}`;
            const analysisResult = analysis[stepKey];
            const recommendationText = resultTexts[stepKey][analysisResult];
            
            // 사진 분석일 경우에만 근거 텍스트 추가
            const basisText = fromPhoto ? `<span class="photo-basis">(사진 분석: ${photoBasisTexts[stepKey][analysisResult]})</span>` : '';
            
            const stepTitles = ["두께:", "위쪽 모양:", "아래쪽 모양:", "산/꼬리 길이:", "전체 길이:", "앞머리:"];
            const stepSuffix = (i === 1) ? " 눈썹" : (i === 5) ? " 그리는 눈썹" : (i === 6) ? " 앞머리" : "";

            listItemsHTML += `
                <li>
                    <strong>${stepTitles[i-1]}</strong> ${recommendationText}${stepSuffix}
                    ${basisText}
                </li>
            `;
        }

        const resultHTML = `
            <div class="result-card">
                <h3>${title}</h3>
                <p>${intro}</p>
                <br>
                <h4>당신에게 제안하는 눈썹의 주요 특징:</h4>
                <ul>
                    ${listItemsHTML}
                </ul>
                <br>
                <p>${outro}</p>
            </div>
        `;
        content.innerHTML = resultHTML;
    }
</script>
</body>
</html>
