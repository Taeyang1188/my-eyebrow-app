<script>
    // 전역 변수 및 설정
    const pages = document.querySelectorAll('.page');
    const loader = document.getElementById('loader');
    const analyzeBtn = document.getElementById('analyze-btn');
    let modelsLoaded = false;

    // [수정 완료] 페이지 전환 및 초기화 함수
    function showPage(pageId) {
        pages.forEach(page => page.classList.remove('active'));
        document.getElementById(pageId).classList.add('active');

        if (pageId === 'start-page') {
            const fileInput = document.getElementById('file-input');
            const userImage = document.getElementById('user-image');
            const slidersContainer = document.getElementById('sliders-container');
            const analyzeBtn = document.getElementById('analyze-btn');
            const canvas = document.getElementById('overlay-canvas');
            const ctx = canvas.getContext('2d');

            fileInput.value = '';
            userImage.src = '';
            userImage.style.display = 'none';
            slidersContainer.style.display = 'none';
            analyzeBtn.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    // 모델 로드 함수
    async function loadModels() {
        const MODEL_URL = './models';
        try {
            console.log("모델 로딩을 시작합니다...");
            await Promise.all([
                faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL),
                faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL)
            ]);
            modelsLoaded = true;
            console.log("모델 로딩 완료! 이제 사진 분석을 할 수 있습니다.");
        } catch (error) {
            console.error("모델 로딩 실패:", error);
            alert("분석 모델을 불러오는 데 실패했습니다. 페이지를 새로고침 해주세요.");
        }
    }
    loadModels();

    // 사진 관련 UI 스크립트
    const fileInput = document.getElementById('file-input');
    const userImage = document.getElementById('user-image');
    const slidersContainer = document.getElementById('sliders-container');
    const guideContainer = document.getElementById('guide-container');

    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const canvas = document.getElementById('overlay-canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const reader = new FileReader();
        reader.onload = (e) => {
            userImage.src = e.target.result;
            userImage.style.display = 'block';
            userImage.onload = () => {
                slidersContainer.style.display = 'block';
                analyzeBtn.style.display = 'block';
                document.getElementById('size-slider').value = 80;
                document.getElementById('opacity-slider').value = 0.7;
                userImage.style.width = '80%';
                userImage.style.opacity = '0.7';
                userImage.style.top = '50%';
                userImage.style.left = '50%';
            };
        };
        reader.readAsDataURL(file);
    });

    // 드래그 기능
    let isImageDragging = false;
    let startX, startY, initialLeft, initialTop;
    userImage.addEventListener('mousedown', e => {
        if (!userImage.src) return;
        e.preventDefault();
        isImageDragging = true;
        userImage.style.cursor = 'grabbing';
        startX = e.clientX;
        startY = e.clientY;
        initialLeft = userImage.offsetLeft;
        initialTop = userImage.offsetTop;
        window.addEventListener('mousemove', dragImage);
        window.addEventListener('mouseup', stopDragImage);
    });
    function dragImage(e) {
        if (!isImageDragging) return;
        userImage.style.left = `${initialLeft + (e.clientX - startX)}px`;
        userImage.style.top = `${initialTop + (e.clientY - startY)}px`;
    }
    function stopDragImage() {
        isImageDragging = false;
        userImage.style.cursor = 'grab';
        window.removeEventListener('mousemove', dragImage);
        window.removeEventListener('mouseup', stopDragImage);
    }

    // 슬라이더 기능
    document.getElementById('size-slider').addEventListener('input', (e) => {
        userImage.style.width = `${e.target.value}%`;
    });
    document.getElementById('opacity-slider').addEventListener('input', (e) => {
        userImage.style.opacity = e.target.value;
    });

    // [수정 완료] 사진 분석 함수
    async function analyzePhoto() {
        if (!modelsLoaded) { alert("분석 모델이 아직 로딩 중입니다. 잠시 후 다시 시도해주세요."); return; }
        if (!userImage.src || userImage.style.display === 'none') { alert("먼저 사진을 선택해주세요."); return; }
        loader.style.display = 'block';
        analyzeBtn.style.display = 'none';
        try {
            const detection = await faceapi.detectSingleFace(userImage, new faceapi.SsdMobilenetv1Options()).withFaceLandmarks();
            if (!detection) {
                loader.style.display = 'none';
                analyzeBtn.style.display = 'block';
                alert("얼굴을 인식할 수 없습니다. 더 선명하고 정면을 바라보는 사진을 사용해주세요.");
                return;
            }
            const canvas = document.getElementById('overlay-canvas');
            const ctx = canvas.getContext('2d');
            const imageRect = userImage.getBoundingClientRect();
            const containerRect = guideContainer.getBoundingClientRect();
            canvas.style.top = `${imageRect.top - containerRect.top}px`;
            canvas.style.left = `${imageRect.left - containerRect.left}px`;
            canvas.style.width = `${imageRect.width}px`;
            canvas.style.height = `${imageRect.height}px`;
            canvas.width = imageRect.width;
            canvas.height = imageRect.height;
            const displaySize = { width: imageRect.width, height: imageRect.height };
            const resizedDetections = faceapi.resizeResults(detection, displaySize);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);
            const landmarks = detection.landmarks;
            const jaw = landmarks.getJawOutline();
            const leftEye = landmarks.getLeftEye();
            const rightEye = landmarks.getRightEye();

            let score = 0;
            const faceHeight = jaw[8].y - (jaw[0].y + jaw[16].y) / 2;
            const faceWidth = jaw[16].x - jaw[0].x;
            const aspectRatio = faceHeight / faceWidth;
            if (aspectRatio > 1.3) score++;
            const leftEyeCenterY = (leftEye[1].y + leftEye[2].y + leftEye[4].y + leftEye[5].y) / 4;
            const leftEyebrowY = (landmarks.getLeftEyeBrow()[0].y + landmarks.getLeftEyeBrow()[1].y + landmarks.getLeftEyeBrow()[2].y + landmarks.getLeftEyeBrow()[3].y + landmarks.getLeftEyeBrow()[4].y) / 5;
            const eyeToEyebrowDistance = leftEyeCenterY - leftEyebrowY;
            const leftEyeHeight = (leftEye[4].y + leftEye[5].y) / 2 - (leftEye[1].y + leftEye[2].y) / 2;
            const normalizedDistance = eyeToEyebrowDistance / leftEyeHeight;
            if (normalizedDistance > 1.0) score++;
            const step1 = (score >= 1) ? 'A' : 'B';
            const p1 = jaw[2], p2 = jaw[4], p3 = jaw[8];
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.sqrt(v1.x**2 + v1.y**2), magnitude2 = Math.sqrt(v2.x**2 + v2.y**2);
            const jawAngle = Math.acos(dotProduct / (magnitude1 * magnitude2)) * (180 / Math.PI);
            const step2 = (jawAngle < 145) ? 'D' : 'C';
            const leftEyeWidth = leftEye[3].x - leftEye[0].x;
            const step3 = (leftEyeWidth / leftEyeHeight < 3.0) ? 'E' : 'F';
            const midEyesX = (leftEye[0].x + rightEye[3].x) / 2;
            const eyeSpreadRatio = Math.abs(midEyesX - landmarks.getNose()[0].x) / faceWidth;
            const step4 = (eyeSpreadRatio < 0.03) ? 'A' : 'B';
            const step5 = (aspectRatio < 1.2) ? 'C' : 'D';
            const step6 = (step4 === 'A' || step2 === 'C') ? 'E' : 'F';
            const analysisResult = { step1, step2, step3, step4, step5, step6 };
            displayResults(analysisResult);
            showPage('result-page');
        } catch (error) {
            console.error("사진 분석 중 오류 발생:", error);
            alert("사진을 분석하는 중에 오류가 발생했습니다. 다른 사진으로 시도해보거나, 설문으로 진단하는 방법을 이용해주세요.");
        } finally {
            loader.style.display = 'none';
            analyzeBtn.style.display = 'block';
        }
    }

    // [수정 완료] 설문 분석 함수
    function analyzeQuiz() {
        const form = document.getElementById('quiz-form');
        const analysisResult = {
            step1: form.elements['q1'].value,
            step2: form.elements['q2'].value,
            step3: form.elements['q3'].value,
            step4: form.elements['q4'].value,
            step5: form.elements['q5'].value,
            step6: form.elements['q6'].value,
        };
        if (Object.values(analysisResult).some(v => !v)) {
            alert("모든 질문에 답변해주세요!");
            return;
        }
        displayResults(analysisResult);
        showPage('result-page');
    }

    // [전면 수정] 최종 결과 표시 함수
    function displayResults(analysis) {
        const content = document.getElementById('result-content');
        const resultTexts = {
            step1: { A: "도톰한", B: "얇은" },
            step2: { C: "산이 없는 부드러운 곡선 형태", D: "산이 있는 직선적이고 각진 형태" },
            step3: { E: "아래쪽을 아치처럼 파주는 곡선형", F: "아래쪽이 완만한 일자형" },
            step4: { A: "산이 길고 꼬리가 짧은 형태", B: "산이 짧고 꼬리가 긴 형태" },
            step5: { C: "얼굴이 덜 동그래 보이도록 조금 길게", D: "얼굴의 세로 길이를 보완하도록 조금 짧게" },
            step6: { E: "옅고 부드럽게 표현하는", F: "또렷하고 결을 살려 표현하는" }
        };
        let title, intro, outro;
        if (analysis.step2 === 'C') {
            title = `당신의 매력을 극대화할 "<strong>부드럽고 청순한 동안 눈썹</strong>"`;
            intro = "축하드립니다! 당신은 부드럽고 청순하며 어려 보이는 동안 인상을 가장 잘 어필할 수 있는 타입입니다. 당신의 매력을 더욱 돋보이게 할 눈썹은 과도한 각 없이 부드러운 곡선 형태를 유지하며, 전체적으로 완만하고 자연스러운 흐름을 가지는 것이 핵심입니다.";
            outro = "이 모든 요소를 종합하여 당신의 얼굴에 찰떡같이 어울리는 눈썹을 완성해 보세요. 자연스러운 아름다움으로 당신의 청순하고 귀여운 매력을 한껏 뽐낼 수 있을 것입니다!";
        } else {
            title = `당신의 품격을 높일 "<strong>세련되고 뚜렷한 성숙 눈썹</strong>"`;
            intro = "축하드립니다! 당신은 세련되고 뚜렷하며 고급스러운 성숙한 인상을 가장 잘 나타낼 수 있는 타입입니다. 당신의 매력을 더욱 강조할 눈썹은 직선적인 요소를 활용하여 또렷한 인상을 부여하고, 적절한 산을 통해 입체감과 시원함을 더하는 것이 중요합니다.";
            outro = "이 모든 요소를 종합하여 당신의 얼굴에 찰떡같이 어울리는 눈썹을 완성해 보세요. 당신의 세련되고 강렬한 매력을 더욱 빛나게 할 것입니다!";
        }
        const resultHTML = `
            <div class="result-card">
                <h3>${title}</h3>
                <p>${intro}</p>
                <br>
                <h4>당신에게 제안하는 눈썹의 주요 특징:</h4>
                <ul>
                    <li><strong>두께:</strong> ${resultTexts.step1[analysis.step1]} 눈썹</li>
                    <li><strong>위쪽 모양:</strong> ${resultTexts.step2[analysis.step2]}</li>
                    <li><strong>아래쪽 모양:</strong> ${resultTexts.step3[analysis.step3]}</li>
                    <li><strong>산/꼬리 길이:</strong> ${resultTexts.step4[analysis.step4]}</li>
                    <li><strong>전체 길이:</strong> ${resultTexts.step5[analysis.step5]} 그리는 눈썹</li>
                    <li><strong>앞머리:</strong> ${resultTexts.step6[analysis.step6]} 앞머리</li>
                </ul>
                <br>
                <p>${outro}</p>
            </div>
        `;
        content.innerHTML = resultHTML;
    }
</script>
