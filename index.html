<script>
    const pages = document.querySelectorAll('.page');
    const loader = document.getElementById('loader');
    let modelsLoaded = false;

    function showPage(pageId) {
        pages.forEach(page => page.classList.remove('active'));
        const targetPage = document.getElementById(pageId);
        if (targetPage) {
            targetPage.classList.add('active');
        }
        if (pageId === 'start-page') {
            const fileInput = document.getElementById('file-input');
            const userImage = document.getElementById('user-image');
            const photoControls = document.getElementById('photo-controls');
            const analyzeBtn = document.getElementById('analyze-btn');
            const canvas = document.getElementById('overlay-canvas');
            if(fileInput) fileInput.value = '';
            if(userImage) { userImage.src = ''; userImage.style.display = 'none'; }
            if(photoControls) photoControls.style.display = 'none';
            if(analyzeBtn) analyzeBtn.style.display = 'none';
            if(canvas) { canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height); }
            const quizForm = document.getElementById('quiz-form');
            if(quizForm) quizForm.reset();
        }
    }

    async function loadModels() {
        const MODEL_URL = './models';
        try {
            await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
            await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
            modelsLoaded = true;
            console.log("모델 로딩 완료!");
        } catch (error) {
            console.error("모델 로딩 실패:", error);
            alert("분석 모델을 불러오는 데 실패했습니다. (경로 확인: " + MODEL_URL + ")");
        }
    }
    loadModels();

    const fileInput = document.getElementById('file-input');
    const userImage = document.getElementById('user-image');
    const photoControls = document.getElementById('photo-controls');
    const analyzeBtn = document.getElementById('analyze-btn');
    const guideContainer = document.getElementById('guide-container');

    if (fileInput) {
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files()[0];
            if (!file) return;
            document.getElementById('overlay-canvas').getContext('2d').clearRect(0,0,300,400);
            const reader = new FileReader();
            reader.onload = (e) => {
                userImage.src = e.target.result;
                userImage.style.display = 'block';
                if(photoControls) photoControls.style.display = 'block';
                if(analyzeBtn) analyzeBtn.style.display = 'block';
                document.getElementById('size-slider').value = 80;
                userImage.style.width = '80%';
                userImage.style.left = '50%';
                userImage.style.top = '50%';
                document.getElementById('opacity-slider').value = 0.7;
                userImage.style.opacity = '0.7';
                document.getElementById('guideline-size-slider').value = 100;
                updateGuidelineSize(100);
            };
            reader.readAsDataURL(file);
        });
    }

    const sizeSlider = document.getElementById('size-slider');
    const opacitySlider = document.getElementById('opacity-slider');
    if (sizeSlider) {
        sizeSlider.addEventListener('input', (e) => { if(userImage) userImage.style.width = `${e.target.value}%`; });
    }
    if (opacitySlider) {
        opacitySlider.addEventListener('input', (e) => { if(userImage) userImage.style.opacity = e.target.value; });
    }

    const guidelineSVG = document.getElementById('guideline-svg');
    const ovalGuide = document.getElementById('oval-guide');
    const redLine = document.getElementById('red-line');
    const blueLine = document.getElementById('blue-line');
    const greenLines = guidelineSVG.querySelectorAll('.green-line');
    const draggableLineVisual = document.getElementById('draggable-line-visual');
    const draggableLineHandle = document.getElementById('draggable-line-handle');
    const guidelineSizeSlider = document.getElementById('guideline-size-slider');
    const IDEAL_ASPECT_RATIO = 1.3;

    function updateGuidelineSize(sizePercent) {
        const svgWidth = 300;
        const baseRx = svgWidth / 3;
        const rx = baseRx * (sizePercent / 100);
        const ry = rx * IDEAL_ASPECT_RATIO;

        ovalGuide.setAttribute('rx', rx);
        ovalGuide.setAttribute('ry', ry);

        redLine.setAttribute('x1', 150 - rx);
        redLine.setAttribute('x2', 150 + rx);
        blueLine.setAttribute('y1', 200 - ry);
        blueLine.setAttribute('y2', 200 + ry);

        const sectionWidth = (rx * 2) / 3;
        const startX = 150 - rx;
        greenLines()[0].setAttribute('x1', startX + sectionWidth);
        greenLines()[0].setAttribute('x2', startX + sectionWidth);
        greenLines()[0].setAttribute('y1', 200 - ry);
        greenLines()[0].setAttribute('y2', 200 + ry);

        greenLines()[1].setAttribute('x1', startX + (sectionWidth * 2));
        greenLines()[1].setAttribute('x2', startX + (sectionWidth * 2));
        greenLines()[1].setAttribute('y1', 200 - ry);
        greenLines()[1].setAttribute('y2', 200 + ry);

        draggableLineVisual.setAttribute('x1', 150 - rx);
        draggableLineVisual.setAttribute('x2', 150 + rx);
        draggableLineHandle.setAttribute('x1', 150 - rx);
        draggableLineHandle.setAttribute('x2', 150 + rx);
    }

    if(guidelineSizeSlider) {
        guidelineSizeSlider.addEventListener('input', (e) => {
            updateGuidelineSize(e.target.value);
        });
    }
    updateGuidelineSize(100);

    let isImageDragging = false;
    let isLineDragging = false;
    let startX_drag, startY_drag, initialLeft, initialTop;
    let initialLineY;

    if (guideContainer) {
        guideContainer.addEventListener('mousedown', e => {
            if (e.target.id === 'draggable-line-handle') {
                isLineDragging = true;
                initialLineY = parseFloat(draggableLineVisual.getAttribute('y1'));
                const CTM = guidelineSVG.getScreenCTM().inverse();
                const pt = guidelineSVG.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                startY_drag = pt.matrixTransform(CTM).y;
                return;
            }
            if (!userImage.src || userImage.style.display === 'none') return;
            e.preventDefault();
            isImageDragging = true;
            userImage.style.cursor = 'grabbing';
            startX_drag = e.clientX;
            startY_drag = e.clientY;
            initialLeft = userImage.offsetLeft;
            initialTop = userImage.offsetTop;
        });
    }
    window.addEventListener('mousemove', (e) => {
        if (isLineDragging && guidelineSVG) {
            const CTM = guidelineSVG.getScreenCTM().inverse();
            const pt = guidelineSVG.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM);

            const ovalRy = parseFloat(ovalGuide.getAttribute('ry'));
            const minY = 200 - ovalRy;
            const maxY = 200 + ovalRy;
            let newY = initialLineY + (svgP.y - startY_drag);

            newY = Math.max(minY, Math.min(maxY, newY));

            draggableLineVisual.setAttribute('y1', newY);
            draggableLineVisual.setAttribute('y2', newY);
            draggableLineHandle.setAttribute('y1', newY);
            draggableLineHandle.setAttribute('y2', newY);
            return;
        }
        if (isImageDragging && userImage) {
            const transform = window.getComputedStyle(userImage).transform;
            const matrix = new DOMMatrix(transform);
            const currentTranslateX = matrix.m41;
            const currentTranslateY = matrix.m42;

            const newTranslateX = currentTranslateX + (e.clientX - startX_drag);
            const newTranslateY = currentTranslateY + (e.clientY - startY_drag);

            userImage.style.transform = `translate(-50%, -50%) translate(${newTranslateX}px, ${newTranslateY}px)`;
            startX_drag = e.clientX;
            startY_drag = e.clientY;
        }
    });
    window.addEventListener('mouseup', () => {
        if(isLineDragging) {
            isLineDragging = false;
        }
        if(isImageDragging) {
            isImageDragging = false;
            if(userImage) userImage.style.cursor = 'grab';
            const transform = window.getComputedStyle(userImage).transform;
            const matrix = new DOMMatrix(transform);
            const translateX = matrix.m41;
            const translateY = matrix.m42;

            userImage.style.left = `calc(50% + ${translateX}px)`;
            userImage.style.top = `calc(50% + ${translateY}px)`;
            userImage.style.transform = 'translate(-50%, -50%)';
        }
    });

    async function analyzePhoto() {
        if (!modelsLoaded) { alert("분석 모델이 아직 로딩 중입니다."); return; }
        if (!userImage.src || userImage.style.display === 'none') { alert("먼저 사진을 선택해주세요."); return; }
        if(loader) loader.style.display = 'block';
        if(analyzeBtn) analyzeBtn.style.display = 'none';

        try {
            const detection = await faceapi.detectSingleFace(userImage, new faceapi.SsdMobilenetv1Options()).withFaceLandmarks();

            if (!detection) {
                if(loader) loader.style.display = 'none';
                if(analyzeBtn) analyzeBtn.style.display = 'block';
                alert("얼굴을 인식할 수 없습니다. 더 선명하고 정면을 바라보는 사진을 사용해주세요.");
                return;
            }

            const canvas = document.getElementById('overlay-canvas');
            const ctx = canvas.getContext('2d');

            const imageRect = userImage.getBoundingClientRect();
            const containerRect = guideContainer.getBoundingClientRect();

            canvas.style.top = `${imageRect.top - containerRect.top}px`;
            canvas.style.left = `${imageRect.left - containerRect.left}px`;
            canvas.style.width = `${imageRect.width}px`;
            canvas.style.height = `${imageRect.height}px`;
            canvas.width = imageRect.width;
            canvas.height = imageRect.height;

            const displaySize = { width: imageRect.width, height: imageRect.height };
            const resizedDetections = faceapi.resizeResults(detection, displaySize);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);

            const landmarks = detection.landmarks;
            const jaw = landmarks.getJawOutline();
            const leftEye = landmarks.getLeftEye();
            const rightEye = landmarks.getRightEye();
            const leftBrow = landmarks.getLeftEyeBrow();
            const rightBrow = landmarks.getRightEyeBrow();
            const nose = landmarks.getNose();

            // 얼굴 비율
            const faceHeight = jaw()[8].y - (jaw()[0].y + jaw()[16].y) / 2;
            const faceWidth = jaw()[16].x - jaw()[0].x;
            const aspectRatio = faceHeight / faceWidth;

            // 이마 넓이 (눈썹 ~ 헤어라인 추정) - 간접적인 판단
            const browTopY = Math.min(leftBrow()[0].y, rightBrow()[0].y);
            const eyeTopY = Math.min(leftEye()[1].y, rightEye()[1].y);
            const foreheadRatio = (eyeTopY - browTopY) / faceHeight; // 비율로 판단

            // 턱 모양 (각도)
            const p1 = jaw()[2], p2 = jaw()[4], p3 = jaw()[8];
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.sqrt(v1.x**2 + v1.y**2), magnitude2 = Math.sqrt(v2.x**2 + v2.y**2);
            const jawAngle = Math.acos(dotProduct / (magnitude1 * magnitude2)) * (180 / Math.PI);

            // 눈 사이 거리 (미간)
            const interEyeDistance = rightEye()[0].x - leftEye()[3].x;
            const normalizedInterEyeDistance = interEyeDistance / faceWidth; // 얼굴 너비 대비

            const analysisResult = {
                step1: (foreheadRatio < 0.15) ? 'B' : 'A', // 이마가 좁다 vs 넓다 (임계값 조정 가능)
                step2: (jawAngle < 140) ? 'D' : 'C', // 턱이 각짐 vs 둥<0xEB><0x8A><0x8C>
                step3: (leftEye()[3].x - leftEye()[0].x) / ((leftEye()[4].y + leftEye()[5].y) / 2 - (leftEye()[1].y + leftEye()[2].y) / 2) < 3.0 ? 'E' : 'F', // 눈이 둥<0xEA><0xB8><0xB3> vs 김
                step4: (normalizedInterEyeDistance < 0.2) ? 'A' : 'B', // 눈 사이 좁음 vs 넓음 (임계값 조정 가능)
                step5: (aspectRatio < 1.25) ? 'C' : 'D', // 얼굴 동그람 vs 김
                step6: (normalizedInterEyeDistance < 0.22 && foreheadRatio > 0.18) ? 'E' : 'F', // 미간 좁고 이마 넓음 -> 부드러운 인상 (임계값 조정 가능)
                forehead: (foreheadRatio < 0.15) ? '좁은' : '넓은',
                jaw: (jawAngle < 140) ? '각진' : '둥근',
                eyeSpacing: (normalizedInterEyeDistance < 0.2) ? '좁은' : '넓은'
            };

            displayResults(analysisResult, true);
            showPage('result-page');

        } catch (error) {
            console.error("사진 분석 중 오류 발생:", error);
            alert("사진을 분석하는 중에 오류가 발생했습니다. 얼굴이 잘 나온 다른 사진으로 시도해보거나, 설문으로 진단하는 방법을 이용해주세요.");
        } finally {
            if(loader) loader.style.display = 'none';
            if(analyzeBtn) analyzeBtn.style.display = 'block';
        }
    }

    function analyzeQuiz() {
        const form = document.getElementById('quiz-form');
        const analysisResult = {
            step1: form.elements['q1'].value,
            step2: form.elements['q2'].value,
            step3: form.elements['q3'].value,
            step4: form.elements['q4'].value,
            step5: form.elements['q5'].value,
            step6: form.elements['q6'].value,
        };
        if (Object.values(analysisResult).some(v => !v)) {
            alert("모든 질문에 답변해주세요!");
            return;
        }
        displayResults(analysisResult, false);
        showPage('result-page');
    }

    function displayResults(analysis, fromPhoto = false) {
        const content = document.getElementById('result-content');
        if (!content) return;

        let finalType;
        if (analysis.step2 === 'D' && analysis.step1 === 'A') finalType = 'A';
        else if (analysis.step2 === 'D' && analysis.step1 === 'B') finalType = 'B';
        else if (analysis.step2 === 'C' && analysis.step1 === 'A') finalType = 'C';
        else finalType = 'D';

        const typeInfo = {
            'A': {
                title: "Type A : 세련된 파워 셀럽형",
                description: "또렷한 인상을 주는 각진 모양과 풍성하고 도톰한 눈썹의 조합입니다. 자신감 있고 카리스마 넘치는 이미지를 연출하기에 좋습니다. 눈썹의 전체적인 길이는 아래 상세 가이드에서 당신의 얼굴 비율에 맞게 조절하여, 전체적인 인상의 완성도를 높일 수 있습니다.",
                celebrities: ["김혜수", "한소희"],
                image: "https://image.isplus.com/data/isp/image/2025/03/20/isp20250320000163.800x.0.jpg"
            },
            'B': {
                title: "Type B : 시크한 도시 모델형",
                description: "날카롭고 세련된 느낌의 각진 모양과 얇고 정교한 눈썹의 조합입니다. 시크하고 도회적인 분위기를 연출하는 데 효과적입니다. 눈썹의 전체적인 길이는 아래 상세 가이드에서 당신의 얼굴 비율에 맞게 조절하여, 전체적인 인상의 완성도를 높일 수 있습니다.",
                celebrities: ["김서형", "아이유"],
                image: "https://www.elle.co.kr/resources_old/online/org_online_image/el/a15eacb9-d825-4655-9264-24e5b93b58c9.jpg"
            },
            'C': {
                title: "Type C : 부드러운 첫사랑형",
                description: "선하고 부드러운 인상을 주는 둥근 모양과 자연스럽고 도톰한 눈썹의 조합입니다. 청순하고 어려 보이는 이미지를 만드는 데 가장 이상적입니다. 눈썹의 전체적인 길이는 아래 상세 가이드에서 당신의 얼굴 비율에 맞게 조절하여, 전체적인 인상의 완성도를 높일 수 있습니다.",
                celebrities: ["제니(블랙핑크)", "임윤아"],
                image: "https://t1.daumcdn.net/news/202504/18/inews24/20250418141440222zwyv.jpg"
            },
            'D': {
                title: "Type D : 단아한 클래식형",
                description: "부드러운 곡선 모양과 깔끔하고 얇은 눈썹의 조합입니다. 단아하고 클래식한 분위기를 연출하며, 가장 실패 확률이 적은 스타일입니다. 눈썹의 전체적인 길이는 아래 상세 가이드에서 당신의 얼굴 비율에 맞게 조절하여, 전체적인 인상의 완성도를 높일 수 있습니다.",
                celebrities: ["김고은", "송혜교"],
                image: "https://img-s-msn-com.akamaized.net/tenant/amp/entityid/AA1HC3K5.img?w=650&h=865&m=6&x=172&y=224&s=289&d=289"
            }
        };

        const currentType = typeInfo()[finalType];

        const detailTexts = {
            shape: analysis.step2 === 'D' ? '산과 각을 살린' : '부드러운 곡선',
            thickness: analysis.step1 === 'A' ? '도톰한' : '얇은',
            length: analysis.step5 === 'C' ? '조금 길게 그려' : '조금 짧게 그려',
            detail: `눈썹 ${analysis.step4 === 'A' ? '산을 길게, 꼬리를 짧게' : '산을 짧게, 꼬리를 길게'}, ${analysis.step6 === 'E' ? '앞머리는 옅게 표현' : '앞머리 결을 살려 표현'}`
        };

        let analysisDetailsHTML = '';
        if (fromPhoto) {
            analysisDetailsHTML = `
                <h4>사진 분석 결과</h4>
                <ul>
                    <li>이마: ${analysis.forehead} 편입니다.</li>
                    <li>턱: ${analysis.jaw} 편입니다.</li>
                    <li>눈 사이 간격: ${analysis.eyeSpacing} 편입니다.</li>
                    </ul>
                <hr style="border-top: 1px dashed #ccc; margin: 15px 0;">
            `;
        }

        const resultHTML = `
            <div class="result-card">
                <h3>${currentType().title}</h3>
                <p style="font-weight: 500;">${currentType().description}</p>
                ${analysisDetailsHTML}
                <div style="margin: 20px 0;">
                    <img src="${currentType().image}" alt="${currentType().title}" style="width: 100%; border-radius: 8px;">
                    <p style="font-size: 0.9em; color: #555; margin-top: 10px;">(예시: ${currentType().celebrities.join(', ')} 스타일)</p>
                </div>

                <h4>당신을 위한 상세 가이드</h4>
                <ul>
                    <li><strong>모양:</strong> ${detailTexts.shape} 눈썹</li>
                    <li><strong>두께:</strong> ${detailTexts.thickness} 눈썹</li>
                    <li><strong>길이:</strong> ${detailTexts.length} 얼굴 비율 보완</li>
                    <li><strong>디테일:</strong> ${detailTexts.detail}</li>
                </ul>
            </div>
        `;

        content.innerHTML = resultHTML;
    }
</script>
